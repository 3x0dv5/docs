.. _rfc85:

=========================================================================
MS RFC 86: Scale-dependant String Substitutions
=========================================================================

:Date:  2012/10/08
:Author: Thomas Bonfort
:Contact: tbonfort@terriscope.fr
:Status: Draft
:Version: MapServer 6.4

1. Overview
-----------

MapServer has the ability to use multiple layers with MINSCALE/MAXSCALE filtering GROUP'd
together when the need for scale-dependant datasources arises, e.g. like:

.. code-block:: mapfile

   LAYER
     NAME "roads_far"
     GROUP "roads"
     TYPE LINE
     MINSCALE 100000
     DATA "the_geom from roads_far"
     CLASS
       ...
     END
     CLASS
       ...
     END
   END
   LAYER
     NAME "roads_close"
     GROUP "roads"
     TYPE LINE
     MAXSCALE 100000
     DATA "the_geom from roads_close"
     CLASS
       ...
     END
     CLASS
       ...
     END
   END

While this solution works, it has the inconvenience of necessitating a duplication of the
symbology throughout multiple layers, and may require some tweaking in order to hide the
multiple layers in capabilities documents.

The current RFC proposes to mimic our current runtime-substitution_ mechanism to replace tokens
inside a layer's DATA statement. Instead of using an url parameter to accomplish the 
replacements, the token is replaced by a value that is dependant on the current map scale.
      

2. Proposed solution
------------------------

Examples are worth a thousand words here...

2.1. Example 1
---------------------

.. code-block:: mapfile

   LAYER
     ..
     SCALETOKEN
       NAME "foobar"
       VALUES
         "1000" "1000"
         "10000" "10000"
         "1000000" "1000000"
       END
     END
     DATA "the_geom from mytable_%foobar%"  #data comes from a specific table
     DATA "/path/to/roads_%foobar%.shp"  #data comes from a specific shapefile
     DATA "the_geom_%foobar% from roads" #data comes from a specific column in the table
     DATA "the_geom_%foobar% from (select * from roads where priority > %foobar%) as foo" #data is filtered
     CLASS
       ...
     END
   END

In the previous examples, %foobar% would be replaced by:

- 1000 for scales under 5500
- 10000 for scales between 5500 and 505000
- 100000  for scales over 505000

2.2 Example 2
--------------

.. code-block:: mapfile

   LAYER
     ..
     SCALETOKEN
       NAME "table"
       VALUES
         "1000" "roads"
         "10000" "roads_gen_1"
         "1000000" "roads_gen_0"
       END
     END
     DATA "the_geom from %table%"  #data comes from a specific table
     DATA "/path/to/%table%.shp"  #data comes from a specific shapefile
     CLASS
       ...
     END
   END

2.3 Example 3
--------------

.. code-block:: mapfile

   LAYER
     ..
     SCALETOKEN
       NAME "filter"
       VALUES
         "1000" ""
         "10000" "where type in ('motorway','trunk','primary')"
         "1000000" "where type='motorway'"
       END
     END
     DATA "the_geom from (select * from roads %filter%) as foo"
     CLASS
       ...
     END
   END

2.4 Discussion
---------------

- The name of the mapfile keywords to use (SCALETOKEN, VALUES) is up for
  discussion
- Multiple tokens can be used for a single layer, e.g for applying a filter
  *and* hitting generalized tables.
- Scale dependant substitutions would only apply on the layer's DATA. Applying
  it to other elements might make sense, but is more involved in terms of
  impact to the code.
- Bug 3150_ discusses the need for such a substitution, but is much more
  limited in scope.
- It might be desirable to provide SCALETOKEN entries at the MAP level (and 
  not only LAYER level) in case the token has the vocation of being replaced
  in multiple layers.
- Provide a default token to use when scale is irrelevant (queries...)

3. Implementation Details
-------------------------


3.1 Overview
------------

- layerObj gets a new member containing the scale dependant tokens
  applicable.
- the actual struct to use to represent a given token is TBD:

.. code-block:: c

   struct {
      char* name;
      hashtableObj values;
   } scaletoken;

.. code-block:: c

   struct{
      double scale;
      char* value;
   } scaletokeentry;
   
   struct {
      char* name;
      scaletokenentry* entries;
      int numentries;
   } scaletoken;

- in msLayerOpen(), replace tokens inside layerObj->data. TBD:
  
  - add layerObj->processeddata to contain the substituted data, and modify
    drivers to use layerObj->processeddata instead of layerObj->data
  - or, keep using layerObj->data, but a keep a copy of the original to be
    replaced when calling msLayerClose().


3.2 Files affected
------------------

The following files will be modified/created by this RFC:

- mapserver.h/mapfile.c: layerObj members, mapfile keywords
- maplayer.c: call to token replacements inside msLayerOpen(), eventually
  msLayerClose(). Add function to appply the substitutions depending on
  current scale..
- mapshape.c, mappostgis.c, mapogr.c.... : eventually use
  layerObj->processeddata instead of layerObj->data (depending on implementation
  choices)
- maplexer.l: keywords


3.3 MapScript
-------------

add getters/setters on layer scaletokens


3.4 Backwards Compatibilty Issues
---------------------------------

This change provides a new functionality with no backwards compatibility issues
being considered.

4. Security implications
------------------------

The tokens are defined in the mapfile and are not overridable by url, thus
implying no more risk of sql injection or file system traversal than a
classical DATA statement.

4. Performance implications
---------------------------

The token replacement is only done in msLayerOpen(), the performance impact
should be negligeable as this happens only once per rendered layer.


5. Bug ID
---------


6. Voting history
-----------------

None


.. _3150: https://github.com/mapserver/mapserver/issues/3150
.. _runtime-substitution: http://mapserver.org/cgi/runsub.html
